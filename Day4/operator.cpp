///*
//	1. (연산자)오버로딩 (다중성): 다중정의 생성자, 연산자 오버로딩
//	C는 함수를 구분할때는 함수이름으로 구분하지만 C++에서는 함수이름과 값을 다 구분함
//	오버라이딩 : 재 정의 / 상속관계에서의 재정의...
//	아무조건 없이 내가 만든 객체에 대해서 복사해서 다른 객체에게 넣는것
//*/
//#include <iostream>
//
//class MyClass {		// 내가 만든 객체도 자료 형이다 그래서 오버로딩이 가능하다
//private:
//	int m_a, m_b;
//	//const char* m_name;
//public:
//	MyClass(int a = 0 , int b = 0/*, const char* name = nullptr*/) : m_a(a), m_b(b)/*, m_name(name*/) {		// int a =0 이것과 int b = 0으로 초기화 시켰는데 : m_a(a), m_b(b) 이건 초기화가 아니냐?
//
//	}
//	void showMyClass() {
//		std::cout << m_a << ", " << m_b << ", " /*<< m_name*/ << std::endl;
//	}
//};
//
//int main()
//{
//	//MyClass obj{1, 2, "홍길동"};
//	//obj.showMyClass();
//
//	//MyClass obj2;		// 디폴트로 생성자를 입력해서 실행가능함/ 이거 물어보기
//	//obj2 = obj;// EX)num = 10; 이건 당연함 근데 이게 되는거 신기함 /오른쪽에 있는걸 왼쪽에 넣어라 / 디폴트 대입 연산자
//	//			// obj라는 객체를 생성해서 2에다가 넣는거/ 내가 obj2에 맴버변수 함수를 뭫넣고 뭘한지 모르는데 객체안에 객체를 넣는다 이건 좀 신가한거임 파이썬에서는 그냥 가능했을 기능인데 신기한편임
//	//			// > 오버로딩을 했기때문에 가능함
//	//obj2.showMyClass();
//
//	MyClass obj{ 10, 20 };
//	MyClass obj2{ 30, 40 };
//	MyClass obj3 = obj + obj2;	// 이게 되야 정상인데 + 라는 정의를 하지 않아서 불가능함/ 연산자에 대한 오버로딩을 해줘야 가능함
//	// 간접참조 연산자 '::'이거랑 '.'이거는 오버로딩이 불가능함
//
//
//	return 0;
//}